<!DOCTYPE html>
<script src='../resources/testharness.js'></script>
<script src='../resources/testharnessreport.js'></script>
<script>

t2 = async_test('Erroring a ReadableStream should reject ReadableStreamReader close promise');
t2.step(function() {
    var controller;
    var rs = new ReadableStream({
        start: function(c) {
            controller = c;
        }
    });

   rs.getReader().closed.then(t2.step_func(function() {
        assert_unreached("closed promise should not be resolved when stream is errored");
    }), t2.step_func(function(err) {
        assert_equals(rsError, err);
        t2.done();
    }));

    var rsError = "my error";
    controller.error(rsError);
});

t3 = async_test('Erroring a ReadableStream should reject ReadableStreamReader close promise');
t3.step(function() {
    var controller;
    var rs = new ReadableStream({
        start: function(c) {
            controller = c;
        }
    });

    var rsError = "my error";
    controller.error(rsError);

    // Let's call getReader twice to ensure that stream is not locked to a reader.
    rs.getReader();
    rs.getReader().closed.then(t3.step_func(function() {
        assert_unreached("closed promise should not be resolved when stream is errored");
    }), t3.step_func(function(err) {
        assert_equals(rsError, err);
        t3.done();
    }));
});

t4 = async_test('Erroring a ReadableStream without any value');
t4.step(function() {
    var controller;
    var rs = new ReadableStream({
        start: function(c) {
            controller = c;
        }
    });

    rs.getReader().closed.then(t3.step_func(function() {
        assert_unreached("closed promise should not be resolved when stream is errored");
    }), t4.step_func(function(err) {
        // Error generated by JS engine.
        assert_true(typeof err == 'object');
        t4.done();
    }));

    controller.error();
});


</script>
